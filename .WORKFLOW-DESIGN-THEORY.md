# Workflow Design Theory

This document describes the effect of the GitHub Actions workflows and issue templates defined in this repository, how they interact, and the design principles they enforce.

---

## Overview

The repository defines four GitHub Actions workflows and three issue template configurations. Together they implement a **contributor gating system**, a **continuous integration pipeline**, and a **release automation pipeline**. The design creates a layered defense against low-quality contributions while keeping the path to contribution straightforward for approved participants.

---

## Workflows

### 1. CI (`ci.yml`)

**Trigger:** Push to `main`, pull requests targeting `main`.

**Concurrency:** Grouped by git ref with `cancel-in-progress: true` — a new push to the same branch cancels any in-flight run, avoiding wasted compute on superseded commits.

**Effect:**

- Checks out the code, installs Node.js 22 with npm caching, and installs native system libraries (Cairo, Pango, libjpeg, giflib, librsvg) needed by canvas/image packages, plus `fd` and `ripgrep` used by tooling.
- Runs `npm ci` (clean, reproducible install from lockfile).
- Runs `npm run build` → `npm run check` → `npm test` in sequence.
- Because all three stages are in a single job, a failure at any stage short-circuits the rest — build errors prevent lint/type-check from running on broken output, and check failures prevent tests from running.

**Design rationale:** A single-job pipeline keeps configuration minimal and execution sequential, which matches a monorepo where packages depend on each other's build artifacts. The concurrency guard prevents queue buildup on active branches.

---

### 2. PR Gate (`pr-gate.yml`)

**Trigger:** `pull_request_target` with type `opened` — runs when a new PR is opened, using the **base branch's** workflow definition (not the PR author's fork). This is critical for security: it prevents untrusted code from modifying the gate logic.

**Effect:**

1. **Bot bypass:** PRs from accounts ending in `[bot]` or from `dependabot[bot]` are allowed through unconditionally.
2. **Collaborator bypass:** If the PR author has `admin` or `write` permission on the repository, they pass without further checks.
3. **Approved contributor check:** For external contributors, the workflow fetches `.github/APPROVED_CONTRIBUTORS` from the default branch and checks if the PR author's GitHub handle appears in the list (case-insensitive).
4. **Rejection:** If the author is not found, the workflow posts a comment explaining the contribution process (open an issue first, get `lgtm` from a maintainer), then **closes the PR automatically**.

**Design rationale:** This implements a human-in-the-loop approval gate that filters out drive-by or AI-generated spam PRs before maintainers need to review code. By using `pull_request_target`, the gate cannot be circumvented by forked PRs modifying the workflow file. The three-tier check (bot → collaborator → approved list) ensures automation and maintainers are never blocked.

---

### 3. Approve Contributor (`approve-contributor.yml`)

**Trigger:** `issue_comment` with type `created` — fires on every new comment on any issue.

**Effect:**

1. **Scope guard:** Only runs on issues (not pull requests), checked via `!github.event.issue.pull_request`.
2. **Comment matching:** The comment body must start with `lgtm` (case-insensitive, word-boundary match). All other comments are ignored.
3. **Permission check:** The commenter must have `admin` or `write` access to the repository. This prevents non-maintainers from approving contributors.
4. **Duplicate check:** If the issue author is already in `.github/APPROVED_CONTRIBUTORS`, posts a comment saying so and exits.
5. **Approval:** Appends the issue author's GitHub handle to `.github/APPROVED_CONTRIBUTORS`, commits and pushes to the default branch, then posts a welcome comment on the issue.

**Design rationale:** This automates the contributor approval handshake. A maintainer only needs to type `lgtm` on an issue — the rest (file edit, commit, push, notification) is handled automatically. The permission check ensures only authorized team members can grant access. Writing directly to the default branch means the next PR from that contributor will immediately pass the PR Gate.

---

### 4. Build Binaries (`build-binaries.yml`)

**Trigger:** Push of a tag matching `v*`, or manual `workflow_dispatch` with a tag input.

**Effect:**

1. Checks out the code at the specified tag.
2. Sets up both **Bun** (1.2.20) and **Node.js** (22) — Bun is used to compile standalone binaries, Node.js for npm registry interaction.
3. Runs `./scripts/build-binaries.sh` which produces platform-specific binaries (darwin-arm64, darwin-x64, linux-x64, linux-arm64, windows-x64).
4. Extracts the changelog section for the tagged version from `packages/coding-agent/CHANGELOG.md`.
5. Creates a GitHub Release with the changelog as release notes and uploads all binary archives. If the release already exists, uploads are clobbered (updated in place).

**Design rationale:** Tag-driven releases decouple the release cadence from the CI pipeline. The `workflow_dispatch` fallback allows re-building binaries without re-tagging. Using pinned action SHAs (instead of version tags) for `actions/checkout` and `actions/setup-node` hardens the supply chain against tag-mutation attacks. The create-or-upload pattern makes the workflow idempotent.

---

## Issue Templates

### Bug Report (`bug.yml`)

Structured form with required fields for description and reproduction steps, optional fields for expected behavior and version. Auto-applies the `bug` label.

### Contribution Proposal (`contribution.yml`)

Structured form requiring "what" and "why" fields, with an optional "how". This is the entry point for the contributor gating system — new contributors must open one of these before submitting a PR.

### Configuration (`config.yml`)

Disables blank issues entirely and directs questions to Discord. This forces all issues through the structured templates, preventing unstructured issue noise.

---

## System Interaction Diagram

```
New contributor arrives
        │
        ▼
Opens "Contribution Proposal" issue
        │
        ▼
Maintainer reviews issue
        │
        ├── Comments "lgtm"
        │       │
        │       ▼
        │   approve-contributor.yml fires
        │       │
        │       ▼
        │   Adds handle to APPROVED_CONTRIBUTORS
        │   Posts welcome comment
        │       │
        │       ▼
        │   Contributor opens PR
        │       │
        │       ▼
        │   pr-gate.yml checks APPROVED_CONTRIBUTORS → ✅ allowed
        │       │
        │       ▼
        │   ci.yml runs build → check → test
        │
        └── Does not approve → contributor cannot open PR
                                (pr-gate.yml auto-closes it)
```

```
Maintainer pushes tag v*
        │
        ▼
build-binaries.yml fires
        │
        ▼
Builds platform binaries via Bun
        │
        ▼
Creates/updates GitHub Release with binaries + changelog
```

---

## Design Principles

1. **Human-in-the-loop gating.** Every new contributor must demonstrate intent through an issue before writing code. This filters low-effort and AI-generated spam at minimal cost to legitimate contributors.

2. **Automation of ceremony.** Once a maintainer says `lgtm`, everything else — file edits, commits, notifications — is automated. The approval workflow eliminates manual file editing and reduces the chance of errors.

3. **Defense in depth.** The PR gate uses `pull_request_target` to prevent fork-based circumvention. The approval workflow checks commenter permissions. The approved list is stored in the repository itself, making it auditable and version-controlled.

4. **Idempotency.** The approval workflow handles duplicates gracefully. The binary build workflow uses create-or-upload to handle re-runs. The CI pipeline uses concurrency cancellation to avoid stale runs.

5. **Supply chain hardening.** The build-binaries workflow pins actions to full commit SHAs rather than mutable version tags, preventing upstream tag-mutation attacks on the release pipeline.

6. **Minimal configuration.** CI uses a single job rather than a matrix or multi-job graph, keeping the pipeline simple for a monorepo where packages have build-order dependencies. Issue templates disable blank issues to funnel all input through structured forms.

7. **Separation of concerns.** CI (quality), PR Gate (access control), Approve Contributor (onboarding), and Build Binaries (release) are independent workflows with no cross-dependencies, making each one easy to reason about and modify in isolation.
